#pragma version 10

smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    txn NumAppArgs
    bz main_bare_routing@8
    method "commit(uint8,uint8,uint8)void"
    method "reveal()(byte[32],uint8[])"
    txna ApplicationArgs 0
    match main_commit_route@4 main_reveal_route@5
    err // reject transaction

main_commit_route@4:
    int 1
    txn OnCompletion
    shl
    int 3
    &
    assert // OnCompletion is one of NoOp, OptIn
    txn ApplicationID
    assert // is not creating
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    callsub commit
    int 1
    return

main_reveal_route@5:
    int 1
    txn OnCompletion
    shl
    int 5
    &
    assert // OnCompletion is one of NoOp, CloseOut
    txn ApplicationID
    assert // is not creating
    callsub reveal
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_bare_routing@8:
    txn OnCompletion
    switch main_create@9 main_reject_bare_on_completion@12 main_reject_bare_on_completion@12 main_reject_bare_on_completion@12 main_update@10 main_delete@11
    err // reject transaction

main_create@9:
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_update@10:
    txn ApplicationID
    assert // is not creating
    callsub update
    int 1
    return

main_delete@11:
    txn ApplicationID
    assert // is not creating
    callsub delete
    int 1
    return

main_reject_bare_on_completion@12:
    err // reject transaction


// smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.commit(delay: bytes, participants: bytes, winners: bytes) -> void:
commit:
    proto 3 0
    int 0
    byte "safety_gap"
    app_global_get_ex
    assert // check self.safety_gap exists
    frame_dig -3
    btoi
    dup
    cover 2
    <=
    assert
    frame_dig -1
    btoi
    dupn 2
    int 1
    >=
    assert
    frame_dig -2
    btoi
    dup
    cover 2
    int 2
    >=
    assert
    int 16
    <=
    bnz commit_bool_true@7
    frame_dig 2
    int 80
    <=
    bz commit_or_contd@3
    frame_dig 1
    int 20
    <=
    bnz commit_bool_true@7

commit_or_contd@3:
    frame_dig 2
    int 47
    <=
    bz commit_or_contd@5
    frame_dig 1
    int 25
    <=
    bnz commit_bool_true@7

commit_or_contd@5:
    frame_dig 2
    int 35
    <=
    bz commit_bool_false@8
    frame_dig 1
    int 30
    <=
    bz commit_bool_false@8

commit_bool_true@7:
    int 1
    b commit_bool_merge@9

commit_bool_false@8:
    int 0

commit_bool_merge@9:
    assert
    frame_dig 1
    frame_dig 2
    <=
    assert
    txn TxID
    global Round
    frame_dig 0
    +
    itob
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    txn Sender
    byte "active_commitment"
    uncover 2
    app_local_put
    retsub


// smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.reveal() -> bytes:
reveal:
    proto 0 1
    byte ""
    dup
    txn Sender
    int 0
    byte "active_commitment"
    app_local_get_ex
    assert // check self.active_commitment exists for account
    txn Sender
    byte "active_commitment"
    app_local_del
    dup
    extract 40 1 // on error: Index access is out of bounds
    btoi
    dup
    uncover 2
    dup
    extract 41 1 // on error: Index access is out of bounds
    btoi
    dup
    cover 3
    cover 3
    global Round
    dig 1
    extract 32 8 // on error: Index access is out of bounds
    dup
    btoi
    uncover 2
    <=
    assert
    itxn_begin
    swap
    extract 0 32 // on error: Index access is out of bounds
    dup
    cover 4
    dup
    len
    itob
    extract 6 2
    swap
    concat
    int 0
    byte "randomness_beacon_id"
    app_global_get_ex
    assert // check self.randomness_beacon_id exists
    itxn_field ApplicationID
    method "must_get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    int appl
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    byte 0x151f7c75
    ==
    assert // ARC4 prefix is valid
    extract 2 0
    callsub pcg128_init
    cover 5
    cover 4
    cover 3
    cover 2
    dup
    int 255
    >=
    dig 1
    int 255
    uncover 2
    select
    byte 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff
    int 0
    uncover 2
    substring3
    cover 2
    <
    bz reveal_ternary_false@3
    frame_dig 3
    frame_bury 1
    b reveal_ternary_merge@4

reveal_ternary_false@3:
    frame_dig 2
    int 1
    -
    frame_bury 1

reveal_ternary_merge@4:
    int 700
    frame_dig 1
    *
    int 0
    callsub ensure_budget
    int 0
    frame_bury 0

reveal_for_header@5:
    frame_dig 0
    frame_dig 1
    <
    bz reveal_after_for@8
    frame_dig 0
    dup
    itob
    frame_dig 2
    itob
    frame_dig 8
    frame_dig 7
    frame_dig 6
    frame_dig 5
    uncover 5
    uncover 5
    int 1
    callsub pcg128_random
    cover 4
    frame_bury 5
    frame_bury 6
    frame_bury 7
    frame_bury 8
    extract 2 0
    extract 0 16 // on error: Index access is out of bounds
    int 15
    getbyte
    frame_dig 9
    dup
    dig 3
    getbyte
    cover 3
    dup
    dig 2
    getbyte
    dig 3
    swap
    setbyte
    swap
    uncover 3
    setbyte
    frame_bury 9
    int 1
    +
    frame_bury 0
    b reveal_for_header@5

reveal_after_for@8:
    frame_dig 3
    dup
    itob
    extract 6 2
    swap
    frame_dig 9
    dup
    cover 2
    len
    dup2
    >=
    select
    int 0
    swap
    substring3
    concat
    frame_dig 4
    byte 0x0022
    concat
    swap
    concat
    frame_bury 0
    retsub


// lib_pcg.pcg128.pcg128_init(seed: bytes) -> uint64, uint64, uint64, uint64:
pcg128_init:
    proto 1 4
    frame_dig -1
    len
    int 32
    ==
    assert
    frame_dig -1
    int 0
    extract_uint64
    int 1442695040888963407
    callsub __pcg32_init
    frame_dig -1
    int 8
    extract_uint64
    int 1442695040888963409
    callsub __pcg32_init
    frame_dig -1
    int 16
    extract_uint64
    int 1442695040888963411
    callsub __pcg32_init
    frame_dig -1
    int 24
    extract_uint64
    int 1442695040888963413
    callsub __pcg32_init
    retsub


// lib_pcg.pcg32.__pcg32_init(initial_state: uint64, incr: uint64) -> uint64:
__pcg32_init:
    proto 2 1
    int 0
    frame_dig -1
    callsub __pcg32_step
    frame_dig -2
    addw
    bury 1
    frame_dig -1
    callsub __pcg32_step
    retsub


// lib_pcg.pcg32.__pcg32_step(state: uint64, incr: uint64) -> uint64:
__pcg32_step:
    proto 2 1
    frame_dig -2
    int 6364136223846793005
    mulw
    bury 1
    frame_dig -1
    addw
    bury 1
    retsub


// algopy.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    int 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    int appl
    itxn_field TypeEnum
    int DeleteApplication
    itxn_field OnCompletion
    byte 0x068101
    itxn_field ApprovalProgram
    byte 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    int 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_after_while@7:
    retsub


// lib_pcg.pcg128.pcg128_random(state.0: uint64, state.1: uint64, state.2: uint64, state.3: uint64, lower_bound: bytes, upper_bound: bytes, length: uint64) -> uint64, uint64, uint64, uint64, bytes:
pcg128_random:
    proto 7 5
    int 0
    dupn 2
    byte ""
    byte 0x0000
    frame_dig -3
    byte 0x
    b==
    bz pcg128_random_else_body@7
    frame_dig -2
    byte 0x
    b==
    bz pcg128_random_else_body@7
    int 0
    frame_bury 3

pcg128_random_for_header@3:
    frame_dig 3
    frame_dig -1
    <
    bz pcg128_random_after_if_else@20
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    callsub __pcg128_unbounded_random
    cover 4
    frame_bury -4
    frame_bury -5
    frame_bury -6
    frame_bury -7
    frame_dig 4
    extract 2 0
    swap
    dup
    len
    int 16
    <=
    assert // overflow
    int 16
    bzero
    b|
    concat
    dup
    len
    int 16
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    frame_dig 3
    int 1
    +
    frame_bury 3
    b pcg128_random_for_header@3

pcg128_random_else_body@7:
    frame_dig -2
    byte 0x
    b!=
    bz pcg128_random_else_body@9
    frame_dig -2
    byte 0x01
    b>
    assert
    frame_dig -2
    byte 0x0100000000000000000000000000000000
    b<
    assert
    frame_dig -2
    byte 0x01
    b-
    frame_dig -3
    b>
    assert
    frame_dig -2
    frame_dig -3
    b-
    frame_bury 0
    b pcg128_random_after_if_else@10

pcg128_random_else_body@9:
    frame_dig -3
    byte 0x80000000000000000000000000000000
    b<
    assert
    byte 0x0100000000000000000000000000000000
    frame_dig -3
    b-
    frame_bury 0

pcg128_random_after_if_else@10:
    frame_dig 0
    dup
    callsub __uint128_twos
    swap
    b%
    frame_bury 2
    int 0
    frame_bury 3

pcg128_random_for_header@11:
    frame_dig 3
    frame_dig -1
    <
    bz pcg128_random_after_for@19

pcg128_random_while_top@13:
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    callsub __pcg128_unbounded_random
    dup
    cover 5
    frame_bury 1
    frame_bury -4
    frame_bury -5
    frame_bury -6
    frame_bury -7
    frame_dig 2
    b>=
    bz pcg128_random_while_top@13
    frame_dig 4
    extract 2 0
    frame_dig 1
    frame_dig 0
    b%
    frame_dig -3
    b+
    dup
    len
    int 16
    <=
    assert // overflow
    int 16
    bzero
    b|
    concat
    dup
    len
    int 16
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 4
    frame_dig 3
    int 1
    +
    frame_bury 3
    b pcg128_random_for_header@11

pcg128_random_after_for@19:

pcg128_random_after_if_else@20:
    frame_dig -7
    frame_dig -6
    frame_dig -5
    frame_dig -4
    frame_dig 4
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    uncover 9
    retsub


// lib_pcg.pcg128.__pcg128_unbounded_random(state.0: uint64, state.1: uint64, state.2: uint64, state.3: uint64) -> uint64, uint64, uint64, uint64, bytes:
__pcg128_unbounded_random:
    proto 4 5
    frame_dig -4
    int 1442695040888963407
    callsub __pcg32_step
    dup
    !
    int 1442695040888963409
    swap
    shl
    frame_dig -3
    swap
    callsub __pcg32_step
    dup
    !
    int 1442695040888963411
    swap
    shl
    frame_dig -2
    swap
    callsub __pcg32_step
    dup
    !
    int 1442695040888963413
    swap
    shl
    frame_dig -1
    swap
    callsub __pcg32_step
    frame_dig -4
    callsub __pcg32_output
    int 32
    shl
    frame_dig -3
    callsub __pcg32_output
    |
    itob
    frame_dig -2
    callsub __pcg32_output
    int 32
    shl
    frame_dig -1
    callsub __pcg32_output
    |
    itob
    concat
    retsub


// lib_pcg.pcg32.__pcg32_output(state: uint64) -> uint64:
__pcg32_output:
    proto 1 1
    frame_dig -1
    int 18
    shr
    frame_dig -1
    ^
    int 27
    shr
    int 4294967295
    &
    frame_dig -1
    int 59
    shr
    dup
    ~
    int 1
    addw
    bury 1
    dig 2
    uncover 2
    shr
    cover 2
    int 31
    &
    shl
    int 4294967295
    &
    |
    retsub


// lib_pcg.pcg128.__uint128_twos(value: bytes) -> bytes:
__uint128_twos:
    proto 1 1
    frame_dig -1
    b~
    byte 0x01
    b+
    byte 0xffffffffffffffffffffffffffffffff
    b&
    retsub


// smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.update() -> void:
update:
    proto 0 0
    txn Sender
    global CreatorAddress
    ==
    assert
    retsub


// smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.delete() -> void:
delete:
    proto 0 0
    txn Sender
    global CreatorAddress
    ==
    assert
    retsub


// smart_contracts.verifiable_giveaway.contract.VerifiableGiveaway.__init__() -> void:
__init__:
    proto 0 0
    byte "randomness_beacon_id"
    int TMPL_RANDOMNESS_BEACON_ID
    app_global_put
    byte "safety_gap"
    int TMPL_SAFETY_ROUND_GAP
    app_global_put
    retsub
